// SPDX-FileCopyrightText: 2025 David Andrs <andrsd@gmail.com>
// SPDX-License-Identifier: MIT

#include "krado/scheme/pinpoint.h"
#include "krado/scheme/integral.h"
#include "krado/mesh_vertex.h"
#include "krado/mesh_curve.h"
#include "krado/mesh_curve_vertex.h"
#include "krado/geom_curve.h"
#include "krado/log.h"
#include <algorithm>

namespace krado {

SchemePinpoint::SchemePinpoint(Options options) : Scheme1D("pinpoint"), opts_(options) {}

void
SchemePinpoint::mesh_curve(Ptr<MeshCurve> curve)
{
    auto & geom_curve = curve->geom_curve();
    auto apos = this->opts_.positions;

    Log::info("Meshing curve {}: scheme='pinpoint'", curve->id());

    // compute arc length
    Integral igrl;
    igrl.integrate(geom_curve, [=](double t) {
        auto der = geom_curve.d1(t);
        return der.magnitude();
    });

    // place mesh curve vertices
    std::sort(apos.begin(), apos.end());
    std::vector<Ptr<MeshCurveVertex>> curve_vtxs;
    for (int count = 1, num_pts = 0; num_pts < apos.size() && count < igrl.num_point();) {
        auto & pt1 = igrl.point(count - 1);
        auto & pt2 = igrl.point(count);
        const auto d = apos[num_pts];
        if ((std::abs(pt1.p) < std::abs(d)) && (std::abs(d) <= std::abs(pt2.p))) {
            const auto dt = pt2.t - pt1.t;
            const auto dlc = pt2.lc - pt1.lc;
            const auto dp = pt2.p - pt1.p;
            const auto t = pt1.t + dt / dp * (d - pt1.p);
            curve_vtxs.push_back(Ptr<MeshCurveVertex>::alloc(geom_curve, t));
            num_pts++;
        }
        else {
            count++;
        }
    }
    if (curve_vtxs.size() == 0)
        throw Exception("No points were generated by pinpoint scheme");

    auto bnd_verts = curve->bounding_vertices();
    if ((geom_curve.type() == GeomCurve::CurveType::Circle) && (bnd_verts.size() == 1)) {
        // curve is a full circle
        curve->add_vertex(bnd_verts[0]);
        for (auto & cv : curve_vtxs)
            curve->add_vertex(cv);

        auto & mvtxs = curve->all_vertices();
        for (std::size_t i1 = 0; i1 < mvtxs.size(); ++i1) {
            auto i2 = (i1 + 1) % mvtxs.size();
            curve->add_segment({ mvtxs[i1], mvtxs[i2] });
        }
    }
    else {
        curve->add_vertex(bnd_verts[0]);
        for (auto & cv : curve_vtxs)
            curve->add_vertex(cv);
        curve->add_vertex(bnd_verts[1]);

        auto & mvtxs = curve->all_vertices();
        for (std::size_t i1 = 0; i1 < mvtxs.size() - 1; ++i1) {
            auto i2 = i1 + 1;
            curve->add_segment({ mvtxs[i1], mvtxs[i2] });
        }
    }
}

} // namespace krado
