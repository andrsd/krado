// SPDX-FileCopyrightText: 2025 David Andrs <andrsd@gmail.com>
// SPDX-License-Identifier: MIT

#pragma once

#include "krado/mesh_vertex_abstract.h"
#include "krado/types.h"
#include "krado/utils.h"
#include <array>
#include <iostream>

namespace krado {

/// Mesh element (generated by a mesh generator, i.e. not read from a mesh file)
class MeshElement {
public:
    /// Build an element
    ///
    /// @param type Element type
    /// @param vtx Vertices composing the element
    MeshElement(ElementType type, const std::vector<MeshVertexAbstract *> & vtx);

    /// Get element type
    ///
    /// @return Element type
    [[nodiscard]] ElementType type() const;

    /// Get number of vertices
    ///
    /// @return Number of vertices
    [[nodiscard]] int num_vertices() const;

    /// Get vertex from local index
    ///
    /// @param idx Local vertex index
    /// @return Vertex
    [[nodiscard]] MeshVertexAbstract * vertex(int idx) const;

    const std::vector<MeshVertexAbstract *> & vertices() const;

    MeshElement get_edge(int i) const;

    /// Swap two vertices
    ///
    /// @param idx1 Index of the first vertex
    /// @param idx2 Index of the second vertex
    ///
    /// @note This is useful for reorienting elements
    void swap_vertices(int idx1, int idx2);

private:
    ElementType type_;
    std::vector<MeshVertexAbstract *> vtx_;

public:
    static MeshElement Line2(const std::array<MeshVertexAbstract *, 2> & vtx);
    static MeshElement Tri3(const std::array<MeshVertexAbstract *, 3> & vtx);
    static MeshElement Quad4(const std::array<MeshVertexAbstract *, 4> & vtx);
};

} // namespace krado

inline std::ostream &
operator<<(std::ostream & stream, const krado::MeshElement & el)
{
    stream << "(" << krado::utils::to_str(el.type()) << ":";
    for (auto & vtx : el.vertices())
        stream << " " << vtx;
    stream << ")";
    return stream;
}
